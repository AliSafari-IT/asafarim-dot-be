import { useState, useEffect, useCallback } from 'react';
import { isProduction } from '../configs';

export interface UseAuthOptions {
  authApiBase?: string;               // e.g. http://api.asafarim.local:5101
  meEndpoint?: string;                // e.g. /auth/me
  tokenEndpoint?: string;             // e.g. /auth/token
  logoutEndpoint?: string;            // e.g. /auth/logout
  identityLoginUrl?: string;          // full URL to identity login page
  identityRegisterUrl?: string;       // full URL to identity register page
}

export interface UseAuthResult<TUser = any> {
  isAuthenticated: boolean;
  user: TUser | null;
  token: string | null;
  loading: boolean;
  signOut: (redirectUrl?: string) => Promise<void>;
  signIn: (redirectUrl?: string) => Promise<void>;
  refreshTokenIfNeeded: () => Promise<string | null>;
}

async function fetchIsAuthenticated(base: string, me: string): Promise<boolean> {
  try {
    console.log(`üîç fetchIsAuthenticated: ${base}${me}`);
    const res = await fetch(`${base}${me}`, {
      method: 'GET',
      credentials: 'include',
      headers: {
        'Accept': 'application/json',
        'Cache-Control': 'no-cache'
      }
    });
    console.log(`üîç fetchIsAuthenticated response: ${res.status}`);
    return res.status !== 401;
  } catch (error) {
    console.error('‚ùå fetchIsAuthenticated failed:', error);
    return false;
  }
}

async function fetchUserInfo<TUser>(base: string, me: string): Promise<TUser | null> {
  try {
    console.log(`üë§ fetchUserInfo: ${base}${me}`);
    const res = await fetch(`${base}${me}`, {
      method: 'GET',
      credentials: 'include',
      headers: {
        'Accept': 'application/json',
        'Cache-Control': 'no-cache'
      }
    });
    console.log(`üë§ fetchUserInfo response: ${res.status}`);
    if (!res.ok) {
      console.error('‚ùå User info fetch failed:', res.status, res.statusText);
      return null;
    }
    const userData = (await res.json()) as TUser;
    console.log('üë§ User data received:', userData);
    return userData;
  } catch (error) {
    console.error('‚ùå User info fetch error:', error);
    return null;
  }
}

// fetch token
async function fetchToken(base: string, tokenEndpoint: string): Promise<string | null> {
  try {
    const res = await fetch(`${base}${tokenEndpoint}`, {
      method: 'GET',
      credentials: 'include',
      headers: {
        'Accept': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('auth_token') || ''}`,
        'Cache-Control': 'no-cache'
      }
    });

    if (!res.ok) {
      console.error('Token fetch failed:', res.status, res.statusText);
      return null;
    }
    const data = await res.json();
    return data.token; // Extract token from the response
  } catch (error) {
    console.error('Token fetch error:', error);
    return null;
  }
}

// Helper function to check if token is expired
function isTokenExpired(token: string | null): boolean {
  if (!token) return true;

  try {
    // JWT tokens have 3 parts separated by dots
    const parts = token.split('.');
    if (parts.length !== 3) return true;

    // Decode the payload (second part)
    const payload = JSON.parse(atob(parts[1]));

    // Check if token exists and is expired
    const now = Math.floor(Date.now() / 1000);
    const exp = payload.exp;

    // Return true if token is missing, invalid, or expired
    return !exp || exp <= now;
  } catch {
    // If we can't decode the token, consider it expired
    return true;
  }
}

// Refresh token function
async function refreshToken(base: string): Promise<string | null> {
  try {
    const res = await fetch(`${base}/auth/refresh`, {
      method: 'POST',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Cache-Control': 'no-cache'
      }
    });

    if (!res.ok) {
      console.error('Token refresh failed:', res.status, res.statusText);
      return null;
    }
    const data = await res.json();
    return data.token;
  } catch (error) {
    console.error('Token refresh error:', error);
    return null;
  }
}

export function useAuth<TUser = any>(options?: UseAuthOptions): UseAuthResult<TUser> {
  const isProd = isProduction;
  
  // IMPORTANT: All authentication operations should use Identity API
  // according to SSO-ARCHITECTURE.md
  // The Identity API is accessible at /api/identity on each subdomain via Nginx routing
  const defaultIdentityApiBase = isProd
    ? 'https://identity.asafarim.be/api/identity'
    : 'http://identity.asafarim.local:5177/api/identity';
  
  console.log('üîê shared-ui-react/hooks/useAuth.ts: isProd?', isProd);
  console.log('üîê Identity API Base:', defaultIdentityApiBase);
  
  const authApiBase = options?.authApiBase ?? defaultIdentityApiBase;
  console.log('üîê Using Auth API Base:', authApiBase);
  
  const meEndpoint = options?.meEndpoint ?? '/auth/me';
  const tokenEndpoint = options?.tokenEndpoint ?? '/auth/token';
  const logoutEndpoint = options?.logoutEndpoint ?? '/auth/logout';
  
  console.log('üîê Auth endpoints:', { meEndpoint, tokenEndpoint, logoutEndpoint });

  // For logout, ensure we use the Identity API
  const identityLogoutUrl = `${authApiBase}${logoutEndpoint}`;
  
  const defaultIdentityLogin = isProd ? 'https://identity.asafarim.be/login' : 'http://identity.asafarim.local:5177/login';
  const identityLoginUrl = options?.identityLoginUrl ?? defaultIdentityLogin;

  const [authenticated, setAuthenticated] = useState<boolean>(false);
  const [user, setUser] = useState<TUser | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [token, setToken] = useState<string | null>(null);

  // Move refreshTokenIfNeeded outside of checkAuth so it can be reused
  const refreshTokenIfNeeded = async (currentToken?: string | null): Promise<string | null> => {
    const tokenToCheck = currentToken || localStorage.getItem('auth_token');
    if (isTokenExpired(tokenToCheck)) {
      console.log('Token expired, refreshing...');
      const newToken = await refreshToken(authApiBase);
      if (newToken) {
        localStorage.setItem('auth_token', newToken);
        setToken(newToken);
        console.log('Token refreshed successfully');
        return newToken;
      } else {
        console.log('Token refresh failed, logging out...');
        // If refresh fails, log out
        setAuthenticated(false);
        setUser(null);
        setToken(null);
        localStorage.removeItem('auth_token');
        localStorage.removeItem('refresh_token');
        localStorage.removeItem('user_info');
        return null;
      }
    }
    return tokenToCheck;
  };

  useEffect(() => {
    let mounted = true;
    let refreshInterval: ReturnType<typeof setInterval> | null = null;
    let authCheckInProgress = false; // Prevent multiple simultaneous auth checks

    const checkAuth = async () => {
      // Prevent multiple simultaneous auth checks
      if (authCheckInProgress) {
        console.log('Auth check already in progress, skipping...');
        return;
      }

      authCheckInProgress = true;
      console.log('üîç Checking authentication status...');
      console.log('API Base:', authApiBase);
      console.log('Me endpoint:', meEndpoint);

      try {
        // First check if we have user info in localStorage as fallback
        const storedUserInfo = localStorage.getItem('user_info');
        let fallbackUserInfo = null;
        
        if (storedUserInfo) {
          try {
            fallbackUserInfo = JSON.parse(storedUserInfo);
            console.log('üìù Found user info in localStorage (fallback):', fallbackUserInfo);
          } catch (e) {
            console.warn('‚ö†Ô∏è Failed to parse stored user info:', e);
          }
        }
        
        // Now check with the server
        const ok = await fetchIsAuthenticated(authApiBase, meEndpoint);

        if (ok) {
          console.log('‚úÖ User is authenticated via server');
          const userData = await fetchUserInfo<TUser>(authApiBase, meEndpoint);
          if (mounted) {
            setAuthenticated(true);
            setUser(userData);
            // Also store user info in localStorage as fallback
            try {
              localStorage.setItem('user_info', JSON.stringify(userData));
            } catch (e) {
              console.warn('‚ö†Ô∏è Failed to store user info in localStorage:', e);
            }
          }

          console.log('üîë Fetching token for authenticated user...');
          const authToken = await fetchToken(authApiBase, tokenEndpoint);
          if (authToken) {
            // Use refreshTokenIfNeeded to ensure we have a valid token
            const validToken = await refreshTokenIfNeeded(authToken);
            if (validToken && mounted) {
              setToken(validToken);
              localStorage.setItem('auth_token', validToken);
              console.log('‚úÖ Valid token stored in localStorage');
            } else if (mounted) {
              // Token refresh failed, log out
              console.warn('‚ö†Ô∏è Token refresh failed during auth check');
              setAuthenticated(false);
              setUser(null);
              setToken(null);
              localStorage.removeItem('auth_token');
            }
          } else {
            console.log('‚ö†Ô∏è No token received from API');
            if (mounted) {
              setToken(null);
            }
          }
        } else if (fallbackUserInfo) {
          // If server says not authenticated, but we have fallback user info,
          // try one token refresh before giving up
          console.log('üîÑ Server says not authenticated but found local user info, attempting token refresh');
          const newToken = await refreshToken(authApiBase);
          
          if (newToken) {
            console.log('‚úÖ Token refreshed, setting user from fallback info');
            if (mounted) {
              setToken(newToken);
              setAuthenticated(true);
              setUser(fallbackUserInfo as TUser);
              localStorage.setItem('auth_token', newToken);
            }
          } else {
            console.log('‚ùå Token refresh failed, user not authenticated');
            if (mounted) {
              setAuthenticated(false);
              setUser(null);
              setToken(null);
            }
          }
        } else {
          console.log('‚ùå User is not authenticated');
          if (mounted) {
            setAuthenticated(false);
            setUser(null);
            setToken(null);
            // Don't clear localStorage or cookies here - only signOut should do that
            // This prevents clearing auth data right after a successful login
          }
        }

        if (mounted) {
          setLoading(false);
        }
      } catch (error) {
        console.error('‚ùå Auth check error:', error);
        if (mounted) {
          setAuthenticated(false);
          setUser(null);
          setToken(null);
          setLoading(false);
        }
      } finally {
        authCheckInProgress = false;
      }
    };

    // Initial check
    void checkAuth();
    
    // Removed delayed re-check as it was causing logout after login
    // The initial check is sufficient, and storage events will trigger re-checks if needed
    // const delayId = 0; // Placeholder for cleanup

    // Debounce auth checks to prevent too frequent checks
    let authCheckTimeout: ReturnType<typeof setTimeout> | null = null;
    const debouncedHandle = () => {
      if (authCheckTimeout) {
        clearTimeout(authCheckTimeout);
      }
      authCheckTimeout = setTimeout(() => {
        if (mounted) {
          void checkAuth();
        }
      }, 500); // 500ms debounce
    };

    const onStorage = (evt: StorageEvent) => {
      if (evt.key === 'auth_token' || evt.key === 'user_info') {
        debouncedHandle();
      }
    };
    
    // Handle sign-out event: clear state immediately, don't re-check auth
    const handleSignOutEvent = () => {
      console.log('üö™ Sign-out event received, clearing auth state...');
      if (mounted) {
        setAuthenticated(false);
        setUser(null);
        setToken(null);
        localStorage.removeItem('auth_token');
        localStorage.removeItem('refresh_token');
        localStorage.removeItem('user_info');
      }
    };
    
    window.addEventListener('auth-signout', handleSignOutEvent);
    // Remove focus and visibilitychange listeners as they trigger too frequently
    // and can interfere with the login flow
    // window.addEventListener('focus', debouncedHandle);
    // document.addEventListener('visibilitychange', debouncedHandle);
    window.addEventListener('storage', onStorage);

    return () => {
      mounted = false;
      if (authCheckTimeout) {
        clearTimeout(authCheckTimeout);
      }
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
      window.removeEventListener('auth-signout', handleSignOutEvent);
      window.removeEventListener('storage', onStorage);
    };
  }, [authApiBase, meEndpoint, tokenEndpoint]);

  // Separate effect for token refresh interval
  useEffect(() => {
    let refreshInterval: ReturnType<typeof setInterval> | null = null;

    if (authenticated) {
      // Refresh token every 45 minutes (with 60-minute token lifetime, gives 15-minute buffer)
      refreshInterval = setInterval(async () => {
        console.log('üîÑ Auto-refreshing token (periodic check)...');
        await refreshTokenIfNeeded();
      }, 45 * 60 * 1000); // 45 minutes
    }

    return () => {
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
    };
  }, [authenticated]);

  const signOut = useCallback(async (redirectUrl?: string) => {
    console.log('üîë Signing out user');
    
    // Clear local state
    setAuthenticated(false);
    setUser(null);
    setToken(null);

    // Clear localStorage
    try {
      localStorage.removeItem('auth_token');
      localStorage.removeItem('refresh_token');
      localStorage.removeItem('user_info');
      console.log('üóëÔ∏è Cleared localStorage authentication data');
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to clear local storage:', error);
    }

    // Clear cookies (CRITICAL: use correct cookie names 'atk' and 'rtk')
    const cookieDomain = isProd ? '.asafarim.be' : '.asafarim.local';
    console.log('üç™ Deleting cookies for domain:', cookieDomain);
    
    // Set multiple variants with different attributes to ensure cookies are cleared
    // 1. With domain and path
    document.cookie = `atk=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT; domain=${cookieDomain}`;
    document.cookie = `rtk=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT; domain=${cookieDomain}`;
    
    // 2. Without domain (current domain only)
    document.cookie = `atk=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT`;
    document.cookie = `rtk=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT`;
    
    // 3. With SameSite=None and Secure for cross-domain cookies
    document.cookie = `atk=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT; domain=${cookieDomain}; SameSite=None; Secure`;
    document.cookie = `rtk=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT; domain=${cookieDomain}; SameSite=None; Secure`;
    
    // 4. With all root paths
    document.cookie = `atk=; path=/api; expires=Thu, 01 Jan 1970 00:00:01 GMT; domain=${cookieDomain}`;
    document.cookie = `rtk=; path=/api; expires=Thu, 01 Jan 1970 00:00:01 GMT; domain=${cookieDomain}`;
    
    // Check cookies after attempting to clear them
    console.log('üîç Checking if cookies were cleared, current cookies:', document.cookie);

    // Notify backend - make this more robust
    try {
      console.log('üì£ Notifying backend about logout:', identityLogoutUrl);
      const response = await fetch(identityLogoutUrl, {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache'
        },
        body: JSON.stringify({
          returnUrl: redirectUrl || '/'
        })
      });

      if (response.ok) {
        console.log('‚úÖ Backend logout successful');
      } else {
        console.warn('‚ö†Ô∏è Logout request failed:', response.status);
        try {
          const errorText = await response.text();
          console.warn('Error details:', errorText);
        } catch (e) {
          // Ignore error text parsing issues
        }
      }

      // Clear site data using Clear-Site-Data header if supported
      try {
        await fetch('https://identity.asafarim.be/clear-cookies', {
          method: 'GET',
          credentials: 'include',
          cache: 'no-store'
        });
        console.log('üóëÔ∏è Attempted to clear site data via identity service');
      } catch (e) {
        console.warn('‚ö†Ô∏è Clear-site-data request failed:', e);
      }

      // Wait a moment to ensure cookies are fully cleared before redirecting
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Redirect the user, if a URL is provided

      // Small delay to ensure state is updated before redirect
      await new Promise(resolve => setTimeout(resolve, 100));

      // Redirect to home or specified URL
      if (redirectUrl) {
        window.location.href = redirectUrl;
      } else {
        // If no redirect URL specified, reload the current page to reset state
        window.location.reload();
      }
    } catch (error) {
      console.error('Error during sign out:', error);
      // Even if there's an error, force logout and redirect
      setAuthenticated(false);
      setUser(null);
      setToken(null);
      window.dispatchEvent(new Event('auth-signout'));
      window.location.href = redirectUrl || '/';
    }
  }, [authApiBase, identityLogoutUrl, isProd]);

  const signIn = useCallback(async (redirectUrl?: string) => {
    // Use provided redirect URL or current page, but ensure it's a valid URL
    const currentUrl = redirectUrl || window.location.href;

    // Validate and sanitize the return URL to prevent infinite loops
    let returnUrl = currentUrl;
    try {
      const url = new URL(currentUrl, window.location.origin);

      // Prevent infinite loops by ensuring return URL is not the identity login page
      if (url.hostname.includes('identity.') && url.pathname.includes('/login')) {
        console.warn('Preventing redirect to identity login page to avoid infinite loop');
        returnUrl = `${url.protocol}//${url.hostname}`;
      }

      // For AI app, ensure we don't redirect back to a page that immediately requires auth
      if (url.hostname.includes('ai.') && url.pathname === '/chat') {
        // Redirect to home page instead of chat to avoid immediate auth requirement
        returnUrl = `${url.protocol}//${url.hostname}`;
      }

      // Check if we're already on the login page to prevent loops
      if (url.hostname.includes('identity.') && url.pathname === '/login') {
        console.warn('Already on login page, preventing redirect loop');
        return;
      }
    } catch (error) {
      console.error('Invalid return URL:', error);
      returnUrl = window.location.origin;
    }

    const encodedReturnUrl = encodeURIComponent(returnUrl);
    const loginUrl = `${identityLoginUrl}?returnUrl=${encodedReturnUrl}`;

    console.log('Redirecting to login:', loginUrl);
    console.log('Return URL:', returnUrl);

    window.location.href = loginUrl;
  }, [identityLoginUrl]);

  return { isAuthenticated: authenticated, user, token, loading, signOut, signIn, refreshTokenIfNeeded };
}

export default useAuth;


